<!DOCTYPE html>
<html>
<head>
    <title>Realtime Debug & Test</title>
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            padding: 20px; 
            background: #0a0a0a;
            color: #e0e0e0;
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 { color: #10b981; margin-bottom: 20px; }
        h2 { color: #60a5fa; margin-top: 30px; }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .panel {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
        }
        
        .status {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            margin: 10px 0;
        }
        
        .connected { 
            background: #065f46; 
            color: #10b981;
            border: 1px solid #10b981;
        }
        
        .error { 
            background: #7f1d1d; 
            color: #ef4444;
            border: 1px solid #ef4444;
        }
        
        .pending {
            background: #713f12;
            color: #fbbf24;
            border: 1px solid #fbbf24;
        }
        
        button {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px;
            font-weight: 500;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #2563eb;
        }
        
        button.danger {
            background: #ef4444;
        }
        
        button.danger:hover {
            background: #dc2626;
        }
        
        button.success {
            background: #10b981;
        }
        
        button.success:hover {
            background: #059669;
        }
        
        .log {
            padding: 8px 12px;
            margin: 4px 0;
            background: #0a0a0a;
            border-left: 3px solid #333;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 13px;
            border-radius: 4px;
            word-break: break-all;
        }
        
        .log.error {
            border-left-color: #ef4444;
            color: #fca5a5;
        }
        
        .log.success {
            border-left-color: #10b981;
            color: #86efac;
        }
        
        .log.warning {
            border-left-color: #fbbf24;
            color: #fde047;
        }
        
        .log.info {
            border-left-color: #60a5fa;
            color: #93c5fd;
        }
        
        #logs {
            max-height: 400px;
            overflow-y: auto;
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
        }
        
        .info-box {
            background: #1e293b;
            border: 1px solid #475569;
            border-radius: 4px;
            padding: 12px;
            margin: 10px 0;
        }
        
        .info-box strong {
            color: #60a5fa;
        }
        
        input, select {
            background: #262626;
            color: #e0e0e0;
            border: 1px solid #404040;
            padding: 8px 12px;
            border-radius: 4px;
            margin: 5px;
            width: 200px;
        }
        
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <h1>🔧 Realtime Debug & Test Console</h1>
    
    <div class="grid">
        <div class="panel">
            <h2>📡 Connection Status</h2>
            <div id="status" class="status pending">Initializing...</div>
            
            <div class="info-box">
                <strong>Project ID:</strong> <span id="projectId">Loading...</span><br>
                <strong>Channel:</strong> <span id="channelName">Not connected</span><br>
                <strong>Auth Status:</strong> <span id="authStatus">Checking...</span><br>
                <strong>Tables Monitored:</strong> items, columns, item_assignments, item_field_values
            </div>
            
            <h3>🔌 Connection Controls</h3>
            <div class="test-grid">
                <button onclick="checkAuth()">Check Auth</button>
                <button onclick="reconnect()">Reconnect</button>
                <button onclick="disconnect()">Disconnect</button>
                <button onclick="testConnection()">Test DB</button>
            </div>
        </div>
        
        <div class="panel">
            <h2>🧪 Test Operations</h2>
            
            <h3>Items</h3>
            <div class="test-grid">
                <button onclick="createItem()">Create Item</button>
                <button onclick="updateItem()">Update Item</button>
                <button onclick="deleteItem()" class="danger">Delete Item</button>
                <button onclick="moveItem()">Move Item</button>
            </div>
            
            <h3>Columns</h3>
            <div class="test-grid">
                <button onclick="createColumn()">Create Column</button>
                <button onclick="updateColumn()">Update Column</button>
                <button onclick="deleteColumn()" class="danger">Delete Column</button>
            </div>
            
            <h3>Advanced</h3>
            <div class="test-grid">
                <button onclick="assignUser()">Assign User</button>
                <button onclick="updateFieldValue()">Update Field</button>
                <button onclick="bulkCreate()">Bulk Create (5)</button>
            </div>
        </div>
    </div>
    
    <div class="panel">
        <h2>📋 Event Logs</h2>
        <div style="margin: 10px 0;">
            <button onclick="clearLogs()">Clear Logs</button>
            <button onclick="exportLogs()">Export Logs</button>
            <label>
                <input type="checkbox" id="autoScroll" checked> Auto-scroll
            </label>
        </div>
        <div id="logs"></div>
    </div>

    <script>
        // Configuration
        const SUPABASE_URL = "https://loshvtjahbhenrfgpvge.supabase.co";
        const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imxvc2h2dGphaGJoZW5yZmdwdmdlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU5ODcxNjMsImV4cCI6MjA3MTU2MzE2M30.cFR1LAnH9wwYeWDstl2rSXBSeJUu7fiMqbwlvUV8ySk";
        const PROJECT_ID = '00000000-0000-0000-0000-000000000001';
        
        // Initialize Supabase
        const { createClient } = supabase;
        const client = createClient(SUPABASE_URL, SUPABASE_KEY, {
            realtime: {
                params: {
                    eventsPerSecond: 10
                }
            }
        });
        
        // Global variables
        let channel = null;
        let testColumnId = null;
        let testItemId = null;
        let eventCount = 0;
        let allLogs = [];
        
        // DOM elements
        const statusDiv = document.getElementById('status');
        const logsDiv = document.getElementById('logs');
        const projectIdSpan = document.getElementById('projectId');
        const channelNameSpan = document.getElementById('channelName');
        const authStatusSpan = document.getElementById('authStatus');
        
        projectIdSpan.textContent = PROJECT_ID;
        
        // Logging function
        function log(message, type = 'info') {
            eventCount++;
            const timestamp = new Date().toLocaleTimeString('en-US', { 
                hour12: false, 
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit', 
                fractionalSecondDigits: 3 
            });
            
            const logEntry = {
                timestamp,
                message,
                type,
                count: eventCount
            };
            allLogs.push(logEntry);
            
            const div = document.createElement('div');
            div.className = `log ${type}`;
            div.innerHTML = `<strong>[${eventCount}] ${timestamp}</strong> ${message}`;
            logsDiv.appendChild(div);
            
            // Auto-scroll if enabled
            if (document.getElementById('autoScroll').checked) {
                logsDiv.scrollTop = logsDiv.scrollHeight;
            }
            
            // Keep only last 200 logs in DOM
            while (logsDiv.children.length > 200) {
                logsDiv.removeChild(logsDiv.firstChild);
            }
            
            console.log(`[${type.toUpperCase()}]`, message);
        }
        
        // Clear logs
        function clearLogs() {
            logsDiv.innerHTML = '';
            eventCount = 0;
            allLogs = [];
            log('Logs cleared', 'info');
        }
        
        // Export logs
        function exportLogs() {
            const logText = allLogs.map(l => `[${l.timestamp}] [${l.type.toUpperCase()}] ${l.message}`).join('\n');
            const blob = new Blob([logText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `realtime-logs-${Date.now()}.txt`;
            a.click();
            log('Logs exported', 'success');
        }
        
        // Check authentication
        async function checkAuth() {
            log('Checking authentication...', 'info');
            const { data: { session }, error } = await client.auth.getSession();
            
            if (error) {
                log(`Auth error: ${error.message}`, 'error');
                authStatusSpan.textContent = 'Error';
                return;
            }
            
            if (session) {
                log(`Authenticated as: ${session.user.email}`, 'success');
                authStatusSpan.textContent = `✅ ${session.user.email}`;
            } else {
                log('Not authenticated (using anon access)', 'warning');
                authStatusSpan.textContent = '⚠️ Anonymous';
            }
        }
        
        // Test database connection
        async function testConnection() {
            log('Testing database connection...', 'info');
            
            try {
                const { data, error } = await client
                    .from('projects')
                    .select('id, name')
                    .eq('id', PROJECT_ID)
                    .single();
                
                if (error) throw error;
                
                log(`✅ Database connected! Project: ${data.name}`, 'success');
                
                // Test if realtime is enabled
                const { data: realtimeTest, error: rtError } = await client
                    .from('columns')
                    .select('count')
                    .eq('project_id', PROJECT_ID);
                
                if (!rtError) {
                    log(`Found ${realtimeTest[0].count} columns in project`, 'info');
                }
            } catch (error) {
                log(`❌ Database error: ${error.message}`, 'error');
            }
        }
        
        // Initialize test data
        async function initTestData() {
            log('Initializing test data...', 'info');
            
            // Get a test column
            const { data: columns, error: colError } = await client
                .from('columns')
                .select('id, name')
                .eq('project_id', PROJECT_ID)
                .limit(1);
            
            if (columns && columns[0]) {
                testColumnId = columns[0].id;
                log(`Using column: ${columns[0].name} (${testColumnId})`, 'success');
            } else {
                log('No columns found, creating one...', 'warning');
                await createColumn();
            }
            
            // Get a test item
            const { data: items } = await client
                .from('items')
                .select('id, name')
                .limit(1);
            
            if (items && items[0]) {
                testItemId = items[0].id;
                log(`Found test item: ${items[0].name}`, 'info');
            }
        }
        
        // Setup realtime subscription
        function setupRealtime() {
            if (channel) {
                log('Removing existing channel...', 'info');
                client.removeChannel(channel);
            }
            
            const channelName = `debug_${PROJECT_ID}_${Date.now()}`;
            channelNameSpan.textContent = channelName;
            log(`Creating channel: ${channelName}`, 'info');
            
            channel = client
                .channel(channelName)
                .on('postgres_changes',
                    { event: '*', schema: 'public', table: 'items' },
                    (payload) => {
                        const item = payload.new || payload.old;
                        log(`📦 ITEM ${payload.eventType}: ${item?.name || 'unknown'} (ID: ${item?.id})`, 'success');
                    }
                )
                .on('postgres_changes',
                    { event: '*', schema: 'public', table: 'columns', filter: `project_id=eq.${PROJECT_ID}` },
                    (payload) => {
                        const col = payload.new || payload.old;
                        log(`📊 COLUMN ${payload.eventType}: ${col?.name || 'unknown'}`, 'success');
                    }
                )
                .on('postgres_changes',
                    { event: '*', schema: 'public', table: 'item_assignments' },
                    (payload) => {
                        log(`👥 ASSIGNMENT ${payload.eventType}`, 'success');
                    }
                )
                .on('postgres_changes',
                    { event: '*', schema: 'public', table: 'item_field_values' },
                    (payload) => {
                        log(`📝 FIELD VALUE ${payload.eventType}`, 'success');
                    }
                )
                .subscribe((status, err) => {
                    log(`Subscription status: ${status}`, status === 'SUBSCRIBED' ? 'success' : 'warning');
                    
                    if (status === 'SUBSCRIBED') {
                        statusDiv.textContent = '✅ Connected';
                        statusDiv.className = 'status connected';
                        
                        // Send presence to verify
                        channel.track({
                            online_at: new Date().toISOString(),
                        }).then(() => {
                            log('Presence confirmed', 'success');
                        });
                    } else if (status === 'CHANNEL_ERROR') {
                        statusDiv.textContent = '❌ Error';
                        statusDiv.className = 'status error';
                        log(`Channel error: ${err?.message || 'Unknown'}`, 'error');
                    } else if (status === 'TIMED_OUT') {
                        statusDiv.textContent = '⏱️ Timeout';
                        statusDiv.className = 'status error';
                        log('Connection timeout', 'error');
                    } else {
                        statusDiv.textContent = status;
                        statusDiv.className = 'status pending';
                    }
                });
        }
        
        // Reconnect
        function reconnect() {
            log('Reconnecting...', 'info');
            setupRealtime();
        }
        
        // Disconnect
        function disconnect() {
            if (channel) {
                client.removeChannel(channel);
                channel = null;
                statusDiv.textContent = '🔌 Disconnected';
                statusDiv.className = 'status pending';
                channelNameSpan.textContent = 'Not connected';
                log('Disconnected from realtime', 'warning');
            }
        }
        
        // Test operations
        async function createItem() {
            if (!testColumnId) {
                log('No column available', 'error');
                return;
            }
            
            const name = `Test Item ${Date.now()}`;
            log(`Creating item: ${name}`, 'info');
            
            const { data, error } = await client
                .from('items')
                .insert({
                    name,
                    column_id: testColumnId,
                    position: Math.floor(Math.random() * 1000),
                    actual_time: 0
                })
                .select()
                .single();
            
            if (error) {
                log(`Create error: ${error.message}`, 'error');
            } else {
                log(`Created item ID: ${data.id}`, 'success');
                testItemId = data.id;
            }
        }
        
        async function updateItem() {
            if (!testItemId) {
                log('No item to update', 'error');
                return;
            }
            
            const name = `Updated ${Date.now()}`;
            log(`Updating item to: ${name}`, 'info');
            
            const { error } = await client
                .from('items')
                .update({ name })
                .eq('id', testItemId);
            
            if (error) {
                log(`Update error: ${error.message}`, 'error');
            } else {
                log('Item updated', 'success');
            }
        }
        
        async function deleteItem() {
            if (!testItemId) {
                log('No item to delete', 'error');
                return;
            }
            
            log(`Deleting item ${testItemId}`, 'warning');
            
            const { error } = await client
                .from('items')
                .delete()
                .eq('id', testItemId);
            
            if (error) {
                log(`Delete error: ${error.message}`, 'error');
            } else {
                log('Item deleted', 'success');
                testItemId = null;
            }
        }
        
        async function moveItem() {
            if (!testItemId) {
                log('No item to move', 'error');
                return;
            }
            
            // Get another column
            const { data: columns } = await client
                .from('columns')
                .select('id, name')
                .eq('project_id', PROJECT_ID)
                .neq('id', testColumnId)
                .limit(1);
            
            if (!columns || !columns[0]) {
                log('No other column to move to', 'error');
                return;
            }
            
            const newColumnId = columns[0].id;
            log(`Moving item to column: ${columns[0].name}`, 'info');
            
            const { error } = await client
                .from('items')
                .update({ column_id: newColumnId })
                .eq('id', testItemId);
            
            if (error) {
                log(`Move error: ${error.message}`, 'error');
            } else {
                log('Item moved', 'success');
            }
        }
        
        async function createColumn() {
            const name = `Column ${Date.now()}`;
            log(`Creating column: ${name}`, 'info');
            
            const { data, error } = await client
                .from('columns')
                .insert({
                    name,
                    project_id: PROJECT_ID,
                    position: Math.floor(Math.random() * 100),
                    color: '#' + Math.floor(Math.random()*16777215).toString(16)
                })
                .select()
                .single();
            
            if (error) {
                log(`Column create error: ${error.message}`, 'error');
            } else {
                log(`Created column ID: ${data.id}`, 'success');
                if (!testColumnId) testColumnId = data.id;
            }
        }
        
        async function updateColumn() {
            if (!testColumnId) {
                log('No column to update', 'error');
                return;
            }
            
            const name = `Updated Col ${Date.now()}`;
            log(`Updating column to: ${name}`, 'info');
            
            const { error } = await client
                .from('columns')
                .update({ name })
                .eq('id', testColumnId);
            
            if (error) {
                log(`Column update error: ${error.message}`, 'error');
            } else {
                log('Column updated', 'success');
            }
        }
        
        async function deleteColumn() {
            if (!testColumnId) {
                log('No column to delete', 'error');
                return;
            }
            
            log(`Deleting column ${testColumnId}`, 'warning');
            
            const { error } = await client
                .from('columns')
                .delete()
                .eq('id', testColumnId);
            
            if (error) {
                log(`Column delete error: ${error.message}`, 'error');
            } else {
                log('Column deleted', 'success');
                testColumnId = null;
            }
        }
        
        async function assignUser() {
            if (!testItemId) {
                log('No item to assign', 'error');
                return;
            }
            
            // Get current user
            const { data: { user } } = await client.auth.getUser();
            if (!user) {
                log('Not authenticated', 'error');
                return;
            }
            
            log(`Assigning item to ${user.email}`, 'info');
            
            const { error } = await client
                .from('item_assignments')
                .upsert({
                    item_id: testItemId,
                    user_id: user.id
                });
            
            if (error) {
                log(`Assignment error: ${error.message}`, 'error');
            } else {
                log('User assigned', 'success');
            }
        }
        
        async function updateFieldValue() {
            if (!testItemId) {
                log('No item for field update', 'error');
                return;
            }
            
            // Get or create a custom field
            const { data: fields } = await client
                .from('custom_fields')
                .select('id, name')
                .eq('project_id', PROJECT_ID)
                .limit(1);
            
            let fieldId;
            if (fields && fields[0]) {
                fieldId = fields[0].id;
                log(`Using field: ${fields[0].name}`, 'info');
            } else {
                log('No custom fields found', 'error');
                return;
            }
            
            const value = `Value ${Date.now()}`;
            log(`Setting field value to: ${value}`, 'info');
            
            const { error } = await client
                .from('item_field_values')
                .upsert({
                    item_id: testItemId,
                    field_id: fieldId,
                    value
                });
            
            if (error) {
                log(`Field update error: ${error.message}`, 'error');
            } else {
                log('Field value updated', 'success');
            }
        }
        
        async function bulkCreate() {
            if (!testColumnId) {
                log('No column for bulk create', 'error');
                return;
            }
            
            log('Creating 5 items...', 'info');
            
            const items = Array.from({ length: 5 }, (_, i) => ({
                name: `Bulk Item ${Date.now()}-${i}`,
                column_id: testColumnId,
                position: i * 100,
                actual_time: 0
            }));
            
            const { data, error } = await client
                .from('items')
                .insert(items)
                .select();
            
            if (error) {
                log(`Bulk create error: ${error.message}`, 'error');
            } else {
                log(`Created ${data.length} items`, 'success');
            }
        }
        
        // Initialize
        async function init() {
            log('🚀 Initializing Realtime Debug Console', 'info');
            await checkAuth();
            await testConnection();
            await initTestData();
            setupRealtime();
            log('✅ Ready for testing!', 'success');
        }
        
        // Start
        init();
        
        // Cleanup on unload
        window.addEventListener('beforeunload', () => {
            if (channel) {
                client.removeChannel(channel);
            }
        });
    </script>
</body>
</html>